## Analysis

**「分析の前に対話で構造を与える」** - 要件分析と設計フェーズの段階的実行による開発基盤構築

従来の一方的な分析ツールとは異なり、ステークホルダーとの対話を重視し、要件の曖昧さを解消しながら段階的に分析精度を高めることに重点を置いた対話型分析アプローチを実現。最小限の要件入力から、**RDRA（リレーションシップ駆動要件分析）**に基づく体系的な分析ドキュメントまで段階的に展開し、**プロトタイプから本番環境**まで一貫した品質を保証します。

### 使い方

```bash
# Claude に Analysis Mode を依頼（最小限の要件入力）
「[システム名] の analysis を実行して」

# 段階的対話展開：
# 1. 簡単な要件 → RDRA による詳細な要件分析自動生成
# 2. EARS 記法による構造化された要件記述
# 3. 段階的対話を通じた分析の精緻化
# 4. 6つの独立したファイルを生成：
#    - requirements.md: RDRA による完全な要件定義
#    - system_usecase.md: システムレベルのユースケース定義
#    - business_usecase.md: 要約レベルのユースケース定義
#    - user_story.md: アジャイル開発用ユーザーストーリー
#    - architecture_design.md: アーキテクチャパターンと技術選定
#    - nonfunctional_requirements.md: 非機能要件と品質特性
#    - implementation_plan.md: 実装戦略とマイルストーン
```

### 実証された効果（実績）

**2週間で会議室予約システム**

```bash
「会議室予約システムの analysis を実行して」
→ 2週間で本番レベルの予約管理システム完成
→ RDRA による体系的な要件定義
→ 追加要件定義不要
```

**1週間でECサイト分析（新規事業）**

```bash
「ECプラットフォームの analysis を実行して」
→ 新規事業担当者との対話で要件明確化
→ 1週間で投資判断可能な詳細分析完成
→ 分析結果から直接実装に移行可能
```

### オプション（段階的選択）

- なし : フル分析ワークフローを対話で実行
- `--requirements` : 要件定義フェーズのみ対話実行
- `--architecture` : アーキテクチャ設計フェーズのみ対話実行
- `--domain` : ドメインモデル設計フェーズのみ対話実行
- `--planning` : 実装計画フェーズのみ対話実行
- `--generate-docs` : 既存の requirements.md から usecase.md と user_story.md を自動生成

### 基本例

```bash
# 新システムの analysis 作成（最小限入力）
「会議室予約システム
- 利用者認証機能
- 会議室管理
- 予約管理」

# 業務システムの analysis 作成
「在庫管理システム
- 商品登録
- 在庫追跡
- 発注管理」

# Webアプリケーションの analysis 作成
「ECサイト
- 商品カタログ
- ショッピングカート
- 決済処理」
```

### Claude との連携

```bash
# 複雑なシステム analysis
「会議室予約システムの analysis を実行して。認証、予約管理、状態管理を含めて」

# 業務システム analysis
「在庫管理システムの analysis を実行して。商品マスター、入出庫管理、発注アラートを含めて」

# Webアプリケーション analysis
「SNSプラットフォームの analysis を実行して。ユーザー管理、投稿機能、通知システムを含めて」

# API システム analysis
「RESTful API の analysis を実行して。認証、データバリデーション、レート制限を含めて」

# 既存のrequirements.mdからドキュメント生成
「--generate-docs オプションで requirements.md から usecase.md と user_story.md を生成して」
```

### Analysis Mode の特徴

**開発ガイド準拠の分析ワークフロー**

- 開発ガイドの分析フェーズを対話型で実装
- RDRA の体系的分析手法を完全実装
- 各フェーズでステークホルダーと協力的に要件を洗練
- アーキテクチャパターン自動選定ロジック搭載
- @docs/reference/ユースケース作成ガイド.md に準拠する

**4段階の対話的展開**

- **Phase 1**: 要件定義 → 議論 → 承認 → `requirements.md` 生成 + `bussiness_usecase.md` 自動生成 + `system_usecase.md` 自動生成 + `user_story.md` 自動生成
- **Phase 2**: 機能要件（アーキテクチャ・データ・ドメイン・UI設計） → 議論 → 承認 → `architecture_design.md` 生成
- **Phase 3**: 非機能要件（テスト戦略・品質・運用要件） → 議論 → 承認 → `nonfunctional_requirements.md` 生成
- **Phase 4**: 技術選定・実装計画 → 議論 → 承認 → `implementation_plan.md` 生成

**開発ガイド統合機能**

- アーキテクチャパターン自動判定（業務領域・データ複雑性・監査要件による）
- テスト戦略自動選定（ピラミッド・ダイヤモンド・逆ピラミッド形）
- 開発アプローチ推奨（インサイドアウト・アウトサイドイン）
- TDD サイクルとイテレーション開発の組み込み

### 詳細例

```bash
# エンタープライズシステム
「ERPシステムの analysis を実行して。財務、人事、販売、在庫管理を統合して」

# クラウドネイティブシステム
「マイクロサービスの analysis を実行して。API Gateway、サービスメッシュ、監視を含めて」

# データ分析システム
「BI システムの analysis を実行して。データ収集、ETL、ダッシュボード、レポート機能を含めて」

# IoT システム
「IoT プラットフォームの analysis を実行して。デバイス管理、データ収集、リアルタイム分析を含めて」
```

### ドキュメント自動生成オプション

**`--generate-docs` オプション詳細**

```bash
# 既存のrequirements.mdからドキュメント生成
「--generate-docs オプションで requirements.md から usecase.md と user_story.md を生成して」

# 生成フロー：
# 1. requirements.md の存在確認
# 2. ビジネスユースケース部分を抽出
# 3. システムレベルのユースケース（usecase.md）に変換
# 4. ユースケースからアジャイル開発用ユーザーストーリー（user_story.md）に変換

# 生成されるファイル：
# - usecase.md: UC001〜UC010形式のシステムユースケース
# - user_story.md: US-001〜US-016形式、Epic・受け入れ基準・リリース計画含む
```

**生成内容の特徴**

- **usecase.md**: requirements.md のビジネスユースケースをシステムレベルのユースケースに変換
  - UC001〜UC010 形式の体系的な番号付け
  - アクター、前提条件、成功シナリオ、例外フロー
  - システム境界内での機能定義
  - ビジネスユースケースとの明示的なトレーサビリティ確保

- **user_story.md**: usecase.md を基にアジャイル開発用のユーザーストーリーに変換
  - US-001〜US-016 形式の識別子
  - Epic分類とストーリーポイント
  - 受け入れ基準（Given-When-Then形式）
  - リリース計画とスプリント配置
  - 対応するユースケースIDとの双方向リンク維持

**使用条件**

- requirements.md が存在すること
- requirements.md にビジネスユースケースセクションが含まれていること
- RDRA 4層構造で作成された要件分析であること

**トレーサビリティマトリックス**

生成されるドキュメント間で以下のトレーサビリティを自動確保：

```
requirements.md → usecase.md → user_story.md
                    ↓           ↓            ↓
ビジネスユースケース   →  システムユースケース  →  アジャイルストーリー
     (BUC-xxx)          (UC-xxx)           (US-xxx)

【追跡項目】
・ビジネス価値の継承: 業務目的→システム機能→開発価値
・機能要求の一貫性: 業務要求→システム要件→受入基準  
・アクターの対応関係: 業務アクター→システムアクター→ストーリーロール
・品質制約の伝播: 業務制約→システム制約→品質定義
```

**自動生成されるトレーサビリティ情報**

- **ユースケース内**: 対応ビジネスユースケースIDの明記
- **ユーザーストーリー内**: 対応ユースケースIDとの双方向参照
- **Epic分類**: ビジネス価値に基づくストーリーグルーピング  
- **受入基準**: システムユースケースの成功シナリオを基盤とした検証可能条件

```

### 段階的対話ワークフロー（Phase by Phase）

#### Phase 1: 要件定義 & Discussion

**1. 最小限入力からの自動拡張（RDRA 式）**

```
ユーザー: 「会議室予約システム
- 利用者認証機能
- 会議室管理
- 予約管理」

Claude: 「開発ガイドのRDRAワークフローに基づいて分析を生成します。
この理解で正しいですか？

自動生成された4層構造:

【システム価値】
- システムコンテキスト: 会員、スタッフ、ゲストとシステムの関係
- 要求モデル: 各アクターの要求と要件定義

【システム外部環境】  
- ビジネスコンテキスト: 施設・窓口・予約管理の業務構造
- ビジネスユースケース: 会員管理・予約管理の業務分析
- 業務フロー: 問い合わせ・予約の詳細フロー
- 利用シーン: 認証・管理・検索・登録の具体的シーン

【システム境界】
- ユースケース複合図: システム機能の詳細定義
- 画面・帳票モデル: UI要素の定義
- イベントモデル: システム間連携の定義

【システム】
- 情報モデル: エンティティ関係の定義
- 状態モデル: 状態遷移の定義

明示されていない詳細を補完しました。他に必要な機能はありますか？」
```

**2. EARS 記法による構造化要件記述**

```
Claude: 「RDRAのEARS記法で要件を構造化します：

EARS記法による要件定義:

WHEN 会員が会議室を検索する際
GIVEN 日時と人数の条件を入力した場合
THEN システムは利用可能な会議室を表示する
AND 予約可能な時間帯をハイライト表示する

WHILE スタッフが予約管理画面にいる間
THE SYSTEM SHALL リアルタイムで予約状況を更新する
AND 重複予約をチェックして警告を表示する

WHERE 認証が必要な機能に
IS アクセスが試行された場合
THE SYSTEM SHALL ログイン状態を確認する
AND 未認証の場合はログイン画面に遷移する」
```

**3. RDRA図表の自動生成**

```
Claude: 「RDRAに基づき、以下の図表を自動生成しました：

システムコンテキスト図（PlantUML）:
- 利用者とシステムの関係性
- 外部システムとの連携ポイント

ビジネスユースケース図:
- 会員管理業務
- 予約管理業務
- 問い合わせ管理業務

情報モデル図:
- 利用者、予約、会議室、予約可能会議室のエンティティ関係

状態モデル図:
- 予約の状態遷移（未予約→予約中→利用中→完了）
- 利用者の状態遷移（未認証→認証済み→操作中）

これらの図表は適切ですか？」
```

**4. Phase 1 完了と承認**

```
Claude: 「要件定義 Phase が完了しました。
requirements.md を生成してよろしいですか？」
→ 「次に進んで」→ requirements.md 生成

**requirements.md 生成後の追加フロー**:
- requirements.md が存在する場合、ビジネスユースケース部分からシステムレベルの usecase.md を自動作成
- 作成した usecase.md を基に、アジャイル開発用の user_story.md を自動作成

```
Claude: 「requirements.md からビジネスユースケースを抽出してシステムレベルのユースケースファイル usecase.md を作成します。」
→ usecase.md 生成（UC001〜UC010形式）

Claude: 「usecase.md を基にアジャイル開発用のユーザーストーリーファイル user_story.md を作成します。」
→ user_story.md 生成（US-001〜US-016形式、Epic・受け入れ基準・リリース計画含む）
```
```

#### Phase 2: 機能要件 & Discussion

**1. アーキテクチャ設計 + パターン自動判定**

```
Claude: 「開発ガイドのアーキテクチャパターン選定ロジックに基づいて分析します：

既存環境分析:
- プラットフォーム: Java 21, Spring Boot
- データベース: 未設定（PostgreSQL推奨）
- フロントエンド: 未設定（React推奨）

業務領域カテゴリー判定:
- 会議室予約システム → 中核の業務領域

データ構造複雑性:
- 利用者・予約・会議室の関係性 → 中程度

金額・監査要件:
- 予約履歴管理が必要 → 監査記録あり

🎯 自動選定結果:
- アーキテクチャパターン: ドメインモデルパターン
- アーキテクチャスタイル: ポートとアダプター（ヘキサゴナル）
- テスト戦略: ピラミッド形テスト
- 永続化: 単一モデル（PostgreSQL）

この自動判定結果で進めますか？」
```

**2. データモデル設計**

```
Claude: 「RDRA情報モデルに基づいてデータ設計を行います：

エンティティ関係設計:
- 利用者 ←→ 予約 (1:多)
- 予約 ←→ 予約可能会議室 (多:1)
- 予約可能会議室 ←→ 会議室 (多:1)

データベース設計方針:
- 正規化: 第3正規形まで
- 制約: 外部キー制約・一意制約
- インデックス: 検索性能最適化
- 監査証跡: 作成・更新ログ

この設計で進めますか？」
```

**3. ドメインモデル設計**

```
Claude: 「ドメイン駆動設計に基づいてモデルを構築します：

ドメインエンティティ:
- User: 利用者の識別とプロファイル管理
- Reservation: 予約の状態とビジネスルール
- Room: 会議室の属性と利用可能性
- AvailableRoom: 予約可能状態の管理

バリューオブジェクト:
- UserId, Email, ReservationPeriod
- ReservationStatus（予約要求・予約確定・予約取消）

ドメインサービス:
- ReservationDomainService: 予約可能性判定
- RoomAvailabilityService: 空室管理

この設計で進めますか？」
```

**4. UI設計**

```
Claude: 「オブジェクト指向UIデザイン原則に基づいて設計します：

画面構成:
- ログイン画面: 認証処理
- 会議室一覧画面: 検索・フィルタ機能
- 予約画面: 予約フォーム・確認
- 予約管理画面: 予約一覧・キャンセル

UI原則:
- タスク指向: ユーザーの目的に直結
- オブジェクト指向: データとアクションの統合
- レスポンシブ: モバイル対応

この設計で進めますか？」
```

**5. Phase 2 完了と承認**

```
Claude: 「機能要件 Phase が完了しました。
architecture_design.md を生成してよろしいですか？」
→ 「次に進んで」→ architecture_design.md 生成
```

#### Phase 3: 非機能要件 & Discussion

**1. テスト戦略策定**

```
Claude: 「アーキテクチャパターンに基づいてテスト戦略を自動選定します：

選定されたアーキテクチャ: ドメインモデルパターン
↓
推奨テスト戦略: ピラミッド形テスト

テスト構成:
📊 ピラミッド形テスト戦略
- 🔺 E2Eテスト（少数）: ユーザーシナリオ・UI統合
- 🔳 統合テスト（中程度）: API・データベース連携
- 🔻 単体テスト（多数）: ドメインロジック・ビジネスルール

具体的テストツール:
- 単体テスト: JUnit 5 + Mockito
- 統合テスト: Testcontainers + Spring Boot Test
- E2Eテスト: Cucumber + Selenium

カバレッジ目標:
- 単体テスト: 90%以上（ドメインロジック重視）
- 統合テスト: 70%以上（API・DB連携）
- E2Eテスト: 主要ユーザーシナリオ100%

この戦略で進めますか？」
```

**2. 非機能要件定義**

```
Claude: 「システム品質要件を定義します：

パフォーマンス要件:
- レスポンス時間: 1秒以内（通常操作）
- スループット: 1000並行ユーザー対応
- 可用性: 99.5%（年間ダウンタイム43.8時間以内）

セキュリティ要件:
- 認証: JWT + セッション管理
- 認可: ロールベースアクセス制御
- データ保護: HTTPS通信・パスワードハッシュ化
- 監査ログ: 全操作の記録・追跡

これらの要件は適切ですか？」
```

**3. 運用要件定義**

```
Claude: 「システム運用に必要な要件を定義します：

監視・ログ要件:
- アプリケーションログ: エラー・警告・情報ログ
- アクセスログ: API呼び出し・レスポンス時間
- システムメトリクス: CPU・メモリ・ディスク使用率
- ビジネスメトリクス: 予約数・利用率・エラー率

デプロイ・保守要件:
- CI/CD: 自動ビルド・テスト・デプロイ
- バックアップ: 日次データベースバックアップ
- 災害復旧: RPO 24時間・RTO 4時間
- 保守ウィンドウ: 月次メンテナンス（深夜2-4時）

これらの要件は適切ですか？」
```

**4. Phase 3 完了と承認**

```
Claude: 「非機能要件 Phase が完了しました。
nonfunctional_requirements.md を生成してよろしいですか？」
→ 「次に進んで」→ nonfunctional_requirements.md 生成
```

#### Phase 4: 技術選定・実装計画 & Discussion

**1. 技術スタック選定**

```
Claude: 「アーキテクチャ設計に基づいて技術スタックを選定します：

Backend技術スタック:
- Java 21 + Spring Boot 3.x
- Spring Security（認証・認可）
- Spring Data JPA + Hibernate
- PostgreSQL（本番）+ H2（テスト）
- Maven（ビルドツール）

Frontend技術スタック:
- React 18 + TypeScript
- Axios（API通信）
- React Router（ルーティング）
- Material-UI（UIコンポーネント）

この技術選定で進めますか？」
```

**2. ADR作成**

```
Claude: 「アーキテクチャ決定記録（ADR）を作成します：

ADR-001: ドメインモデルパターンの採用
- 決定: ドメインモデルパターンを採用
- 理由: 中核業務領域で複雑なビジネスルールを含む
- 結果: 保守性・拡張性の向上、テスト容易性の確保

ADR-002: ポートとアダプターアーキテクチャの採用
- 決定: ヘキサゴナルアーキテクチャを採用
- 理由: 外部依存からの分離、テスト容易性の確保
- 結果: 技術的詳細からの独立、マイクロサービス対応

これらの決定記録で問題ありませんか？」
```

**3. 実装計画・開発アプローチ**

```
Claude: 「開発ガイドに基づいて実装アプローチを決定します：

開発アプローチ判定:
- CRUD実装済み? → いいえ
- API実装済み? → いいえ
- ドメインモデル採用 → はい

🎯 推奨アプローチ: インサイドアウト
- データベース → インフラ → ドメイン → アプリケーション → プレゼンテーション

実装順序（TDDサイクル適用）:
Week 1: インフラ基盤
- [ ] データベーススキーマ作成
- [ ] インフラストラクチャ層実装
- [ ] JPA Repository実装

Week 2: ドメイン層
- [ ] ドメインエンティティ実装
- [ ] バリューオブジェクト実装  
- [ ] ドメインサービス実装
- [ ] 単体テスト（TDD）

Week 3: アプリケーション・プレゼンテーション層
- [ ] アプリケーションサービス実装
- [ ] REST API実装
- [ ] 統合テスト

この計画で進めますか？」
```

**4. リリース計画**

```
Claude: 「アジャイル開発に基づいてリリース計画を策定します：

イテレーション計画:
Sprint 1（2週間）: インフラ基盤・認証機能
- ユーザーストーリー: ログイン・ログアウト
- 受け入れ条件: 認証成功・失敗の処理

Sprint 2（2週間）: 会議室管理機能
- ユーザーストーリー: 会議室検索・一覧表示
- 受け入れ条件: 空室状況の正確な表示

Sprint 3（2週間）: 予約管理機能
- ユーザーストーリー: 予約作成・キャンセル
- 受け入れ条件: 重複予約の防止・状態管理

リリース判定基準:
- 全受け入れテスト通過
- パフォーマンステスト合格
- セキュリティ監査完了

この計画で進めますか？」
```

**5. Phase 4 完了と承認**

```
Claude: 「技術選定・実装計画 Phase が完了しました。
implementation_plan.md を生成してよろしいですか？」
→ 「次に進んで」→ implementation_plan.md 生成
```

### RDRA 特有の機能

**EARS 記法 (Easy Approach to Requirements Syntax)**
```markdown
# Analysis 標準の EARS 記法パターン

WHEN [状況・トリガー]
GIVEN [前提条件]
THEN [システムの動作]
AND [追加の動作]

WHILE [状態・プロセス]
THE SYSTEM SHALL [必須動作]
AND [関連動作]

WHERE [機能・コンポーネント]
IS [条件・状態]
THE SYSTEM SHALL [対応動作]
```

**自動生成機能**

- **PlantUML 図**: システムコンテキスト・ユースケース・状態遷移図の自動生成
- **Java インターフェース**: 設計に基づくエンティティ・サービス定義自動作成
- **アーキテクチャパターン**: 業務領域分析に基づく最適パターン自動選定
- **品質チェックポイント**: 段階別品質基準の自動設定
- **トレーサビリティマップ**: ビジネスユースケース→システムユースケース→ユーザーストーリーの追跡関係自動生成
- **要件カバレッジマトリックス**: 業務要求の開発ストーリー反映状況の可視化

**hooks 連携**

- ファイル保存時の自動品質チェック
- RDRA整合性の自動検証
- アーキテクチャパターン適合性チェック
- **要件トレーサビリティの自動確認**: ビジネスユースケース・システムユースケース・ユーザーストーリー間の追跡関係検証
- **カバレッジ完全性監視**: 欠落した要件やストーリーの自動検出とアラート

**プロトタイプ→本番品質保証**

- RDRA による体系的アプローチによる一貫した設計
- アーキテクチャパターン強制による品質確保
- 段階的精緻化による実装可能な詳細度
- 継続的品質管理の組み込み

### トリガーフレーズとコントロール

#### 段階的ワークフロー制御

**開始トリガー**

- 「[システム名] の analysis を実行して」
- 「analysis 駆動で [システム名] を分析したい」
- 「RDRA で [システム名] を分析して」

**フェーズ進行制御**

- **「次に進んで」**: 現在のフェーズを完了してファイル生成、次フェーズへ
- **「修正して」**: 現在のフェーズ内で内容を調整・改善
- **「やり直して」**: 現在のフェーズを最初からやり直し
- **「詳しく説明して」**: より詳細な説明や選択肢を提示
- **「スキップして」**: 現フェーズをスキップして次へ（非推奨）

**ファイル生成タイミング**

```
Phase 1 完了 → 「次に進んで」 → requirements.md 生成
                                ゆ→ usecase.md 自動生成（要件分析のビジネスユースケースから変換）
                                → user_story.md 自動生成（ユースケースからアジャイル開発用に変換）
Phase 2 完了 → 「次に進んで」 → architecture_design.md 生成
Phase 3 完了 → 「次に進んで」 → nonfunctional_requirements.md 生成
Phase 4 完了 → 「次に進んで」 → implementation_plan.md 生成
```

### 実行例（段階的フロー）

```bash
# 使用例
ユーザー: 「会議室予約システムの analysis を実行して」

# Phase 1: 要件定義
Claude: [RDRA による要件確認と議論開始]
ユーザー: [応答・議論・修正]
Claude: 「要件定義 Phase が完了しました。次に進んでよろしいですか？」
ユーザー: 「次に進んで」
→ requirements.md 生成
→ usecase.md 自動生成（ビジネスユースケースからシステムユースケースに変換）
→ user_story.md 自動生成（ユースケースからアジャイル開発用ストーリーに変換）

# Phase 2: 機能要件
Claude: [アーキテクチャ・データ・ドメイン・UI設計の提案と議論開始]
ユーザー: [パターン選択・設計議論]
Claude: 「機能要件 Phase が完了しました。次に進んでよろしいですか？」
ユーザー: 「次に進んで」
→ architecture_design.md 生成

# Phase 3: 非機能要件
Claude: [テスト戦略・品質・運用要件の議論開始]
ユーザー: [テスト戦略・品質基準議論]
Claude: 「非機能要件 Phase が完了しました。次に進んでよろしいですか？」
ユーザー: 「次に進んで」
→ nonfunctional_requirements.md 生成

# Phase 4: 技術選定・実装計画
Claude: [技術スタック・ADR・実装計画の議論開始]
ユーザー: [技術選択・開発アプローチ・リリース計画議論]
Claude: 「技術選定・実装計画 Phase が完了しました。次に進んでよろしいですか？」
ユーザー: 「次に進んで」
→ implementation_plan.md 生成

# 完了
Claude: 「開発ガイド準拠の analysis 駆動開発の準備が完了しました。実装を開始できます。」
```

### /spec との違い

| 特徴 | /spec | /analysis |
|------|-------|-----------|
| 対象 | 機能仕様駆動開発 | システム全体の要件分析 |
| 準拠フレームワーク | Kiro 仕様駆動開発 | 開発ガイド + RDRA |
| 出力形式 | 3つの独立したファイル（requirements.md、design.md、tasks.md） | 6つの独立したファイル（requirements.md、usecase.md、user_story.md、architecture_design.md、nonfunctional_requirements.md、implementation_plan.md） |
| 要件定義 | EARS 記法による受け入れ基準 | RDRA 4層構造による体系的分析 |
| 設計 | コードベース分析ベース | 開発ガイドのアーキテクチャパターン自動選定 |
| ドメイン | 機能レベルの設計 | RDRA情報・状態モデルによるドメイン設計 |
| テスト戦略 | 機能テスト重視 | アーキテクチャパターン連動テスト戦略 |
| 実装 | 機能実装タスク | TDD + インサイドアウト/アウトサイドイン |
| 品質保証 | 機能品質要件 | 非機能要件専用フェーズ |
| 開発アプローチ | 仕様駆動 | 開発ガイド準拠アジャイル開発 |

### 推奨ユースケース

**analysis 使用推奨**

- 新システム開発
- システム全体の要件定義
- アーキテクチャ設計
- ドメイン分析
- プロジェクト立ち上げ

**spec 使用推奨**

- 新機能開発
- 機能改修
- API 設計
- UI/UX 実装
- 機能仕様作成

**--generate-docs オプション推奨**

- 既存のrequirements.mdが存在する場合
- usecase.mdとuser_story.mdが未作成の場合
- アジャイル開発を開始する前の準備
- 要件分析完了後のドキュメント整備
- 開発チームとの成果物共有

### 注意事項

**適用範囲**

- Analysis Mode はシステム全体分析に最適化
- 小規模な機能追加の場合は /spec を使用
- 新規システム開発や大規模改修に推奨

**品質保証**

- 各段階での完了基準を明確化
- 実装前の設計レビュー必須
- RDRA 整合性とアーキテクチャ適合性を含む包括的な品質基準
- **トレーサビリティ完全性チェック**: ビジネスユースケース→システムユースケース→ユーザーストーリーの追跡可能性検証
- **要件カバレッジ検証**: 全ビジネス要求がシステム機能として実装され、開発ストーリーに反映されることを保証

**実行上の注意**

- 要件の曖昧さを解消してから設計段階へ
- アーキテクチャ完了後にドメインモデリング
- 各段階での承認プロセスを重視
- RDRA 図表の整合性を常に確認

### 関連コマンド

- `/spec` : 機能仕様駆動開発の実行
- `/plan` : analysis 結果を基にした詳細実装計画
- `/implementation` : 実装フェーズの開始
- `/review` : analysis 結果の品質確認とレビュー